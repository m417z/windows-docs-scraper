# glCopyPixels function

The **glCopyPixels** function copies pixels in the framebuffer.

## Parameters

*x*

The window x-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.

*y*

The window y-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.

*width*

The width dimension of the rectangular region of pixels to be copied. Must be nonnegative.

*height*

The height dimension of the rectangular region of pixels to be copied. Must be nonnegative.

*type*

Specifies whether **glCopyPixels** is to copy color values, depth values, or stencil values. The acceptable symbolic constants are.

| Value | Meaning |
|-------|---------|
|

**GL_COLOR**

| The **glCopyPixels** function reads indexes or RGBA colors from the buffer currently specified as the read source buffer (see [**glReadBuffer**](https://learn.microsoft.com/windows/win32/opengl/glreadbuffer)). <br> If OpenGL is in color-index mode:<br>
1. Each index that is read from this buffer is converted to a fixed-point format with an unspecified number of bits to the right of the binary point.
2. Each index is shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET.If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.\
3. If GL_MAP_COLOR is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_I_TO_I.
4. Whether the lookup replacement of the index is done or not, the integer part of the index is then **AND**ed with 2*b* 1, where *b* is the number of bits in a color-index buffer.

If OpenGL is in RGBA mode:\

1. The red, green, blue, and alpha components of each pixel that is read are converted to an internal floating-point format with unspecified precision.
2. The conversion maps the largest representable component value to 1.0, and component value zero to 0.0.
3. The resulting floating-point color values are then multiplied by GL_c_SCALE and added to GL_c_BIAS, where *c* is RED, GREEN, BLUE, and ALPHA for the respective color components.
4. The results are clamped to the range [0,1].
5. If GL_MAP_COLOR is true, each color component is scaled by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaced by the value that it references in that table; *c* is R, G, B, or A, respectively. The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position *z*-coordinate and texture coordinates to each pixel, and then assigning window coordinates (*x*r + i, *y*r + *j*), where (*x*r , *y*r ) is the current raster position, and the pixel was the pixel in the *i* position in the *j* row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the framebuffer.\

|
|

**GL_DEPTH**

| Depth values are read from the depth buffer and converted directly to an internal floating-point format with unspecified precision. The resulting floating-point depth value is then multiplied by GL_DEPTH_SCALE and added to GL_DEPTH_BIAS. The result is clamped to the range [0,1]. <br> The resulting depth components are then converted to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning window coordinates (*x*r + i, *y*r + *j*), where (*x*r , *y*r ) is the current raster position, and the pixel was the pixel in the *i* position in the *j* row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the framebuffer.<br> |
|

**GL_STENCIL**

| Stencil indexes are read from the stencil buffer and converted to an internal fixed-point format with an unspecified number of bits to the right of the binary point. Each fixed-point index is then shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If GL_MAP_STENCIL is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_S_TO_S. Whether the lookup replacement of the index is done or not, the integer part of the index is then **AND**ed with 2b - 1, where *b* is the number of bits in the stencil buffer. The resulting stencil indexes are then written to the stencil buffer such that the index read from the *i* location of the *j* row is written to location (*x*r + *i*, *y*r + *j*), where (*x*r , *y*r ) is the current raster position. Only the pixel-ownership test, the scissor test, and the stencil writemask affect these writes.<br> |

## Return value

This function does not return a value.

## Error codes

The following error codes can be retrieved by the [**glGetError**](https://learn.microsoft.com/windows/win32/opengl/glgeterror) function.

| Name | Meaning |
|-------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| **GL\_INVALID\_ENUM** | *type* was not an accepted value.<br> |
| **GL\_INVALID\_VALUE** | Either *width* or height was negative.<br> |
| **GL\_INVALID\_OPERATION** | *type* was GL\_DEPTH and there was no depth buffer.<br> |
| **GL\_INVALID\_OPERATION** | *type* was GL\_STENCIL and there was no stencil buffer.<br> |
| **GL\_INVALID\_OPERATION** | The function was called between a call to [**glBegin**](https://learn.microsoft.com/windows/win32/opengl/glbegin) and the corresponding call to [**glEnd**](https://learn.microsoft.com/windows/win32/opengl/glend).<br> |

## Remarks

The **glCopyPixels** function copies a screen-aligned rectangle of pixels from the specified framebuffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined.

The *x* and *y* parameters specify the window coordinates of the lower-left corner of the rectangular region to be copied. The *width* and *height* parameters specify the dimensions of the rectangular region to be copied. Both *width* and *height* must be nonnegative.

Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three functions: [**glPixelTransfer**](https://learn.microsoft.com/windows/win32/opengl/glpixeltransfer), [**glPixelMap**](https://learn.microsoft.com/windows/win32/opengl/glpixelmap), and [**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom). This topic describes the effects on **glCopyPixels** of most, but not all, of the parameters specified by these three functions.

The **glCopyPixels** function copies values from each pixel with the lower-left corner at (*x* + *i*, *y* + *j*) for 0 = *i* < *width* and 0 = *j* < *height*. This pixel is said to be the *i* pixel in the *j* row. Pixels are copied in row order from the lowest to the highest row, left to right in each row.

The *type* parameter specifies whether color, depth, or stencil data is to be copied.

The rasterization described thus far assumes pixel zoom factors of 1.0. If you use [**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows. If (*x*r , *y*r ) is the current raster position, and a given pixel is in the *i* location in the *j* row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at

(*x*r + *zoom*? i, yr + *zoom*y *j*)

and

(*x*r + *zoom*? (*i* + 1), *y*r + *zoom*y (*j* + 1))

where *zoom*? is the value of GL\_ZOOM\_X and *zoom*y is the value of GL\_ZOOM\_Y.

Modes specified by [**glPixelStore**](https://learn.microsoft.com/windows/win32/opengl/glpixelstore-functions) have no effect on the operation of **glCopyPixels**.

The following functions retrieve information related to **glCopyPixels**:

[**glGet**](https://learn.microsoft.com/windows/win32/opengl/glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv) with argument GL\_CURRENT\_RASTER\_POSITION

**glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID

To copy the color pixel in the lower-left corner of the window to the current raster position, use

**glCopyPixels**( 0, 0, 1, 1, GL\_COLOR );

## Requirements

| Requirement | Value |
|-------------------------------------|-----------------------------------------------------------------------------------------|
| Minimum supported client<br> | Windows 2000 Professional \[desktop apps only\]<br> |
| Minimum supported server<br> | Windows 2000 Server \[desktop apps only\]<br> |
| Header<br> | Gl.h |
| Library<br> | Opengl32.lib |
| DLL<br> | Opengl32.dll |

## See also

[**glBegin**](https://learn.microsoft.com/windows/win32/opengl/glbegin)

[**glDepthFunc**](https://learn.microsoft.com/windows/win32/opengl/gldepthfunc)

[**glDrawBuffer**](https://learn.microsoft.com/windows/win32/opengl/gldrawbuffer)

[**glDrawPixels**](https://learn.microsoft.com/windows/win32/opengl/gldrawpixels)

[**glEnd**](https://learn.microsoft.com/windows/win32/opengl/glend)

[**glGet**](https://learn.microsoft.com/windows/win32/opengl/glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv)

[**glPixelMap**](https://learn.microsoft.com/windows/win32/opengl/glpixelmap)

[**glPixelStore**](https://learn.microsoft.com/windows/win32/opengl/glpixelstore-functions)

[**glPixelTransfer**](https://learn.microsoft.com/windows/win32/opengl/glpixeltransfer)

[**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom)

[**glRasterPos**](https://learn.microsoft.com/windows/win32/opengl/glrasterpos-functions)

[**glReadBuffer**](https://learn.microsoft.com/windows/win32/opengl/glreadbuffer)

[**glReadPixels**](https://learn.microsoft.com/windows/win32/opengl/glreadpixels)

[**glStencilFunc**](https://learn.microsoft.com/windows/win32/opengl/glstencilfunc)

