# glDrawPixels function

The **glDrawPixels** function writes a block of pixels to the framebuffer.

## Parameters

*width*

The width dimension of the pixel rectangle that will be written into the framebuffer.

*height*

The height dimension of the pixel rectangle that will be written into the framebuffer.

*format*

The format of the pixel data. Acceptable symbolic constants are as follows.

| Value | Meaning |
|-------|---------|
| **GL_COLOR_INDEX** | Each pixel is a single value, a color index. <br>
1. The **glDrawPixels** function converts each pixel to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. The **glDrawPixels** function converts signed and unsigned integer data with all fraction bits set to zero. The function converts bitmap data to either 0.0 or 1.0.
2. The **glDrawPixels** function shifts each fixed-point index left by GL_INDEX_SHIFT bits and adds it to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.
3. When in RGBA mode, **glDrawPixels** converts the resulting index to an RGBA pixel using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables. When in the color-index mode and GL_MAP_COLOR is true, the index is replaced with the value that **glDrawPixels** references in lookup table GL_PIXEL_MAP_I_TO_I.
4. Whether the lookup replacement of the index is done or not, the integer part of the index is **AND**ed with 2b - 1, where *b* is the number of bits in a color-index buffer.
5. The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position *z*-coordinate and texture coordinates to each pixel, and then assigning *x* and *y* window coordinates to the *n*th fragment such that *x*? = *x*r + *n* mod *width*\
   *y*? = *y*r + *n/width*\
    where (*x*r , *y*r ) is the current raster position.\
6. The **glDrawPixels** function treats these pixel fragments just like the fragments generated by rasterizing points, lines, or polygons. It applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.

|
| **GL_STENCIL_INDEX** | Each pixel is a single value, a stencil index. <br>
1. The **glDrawPixels** function converts it to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. The **glDrawPixels** function converts signed and unsigned integer data with all fraction bits set to zero. Bitmap data converts to either 0.0 or 1.0.
2. The **glDrawPixels** function shifts each fixed-point index left by GL_INDEX_SHIFT bits, and adds it to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.
3. If GL_MAP_STENCIL is true, the index is replaced with the value that **glDrawPixels** references in lookup table GL_PIXEL_MAP_S_TO_S.
4. Whether the lookup replacement of the index is done or not, the integer part of the index is then **AND**ed with 2b - 1, where *b* is the number of bits in the stencil buffer. The resulting stencil indexes are then written to the stencil buffer such that the *n*th index is written to location *x*? = *x*r + *n* mod *width*\
   *y*? = *y*r + *n/width*\
    where (*x*r ,yr ) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.\

|
| **GL_DEPTH_COMPONENT** | Each pixel is a single-depth component. <br>
1. The **glDrawPixels** function converts floating-point data directly to an internal floating-point format with unspecified precision. Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.
2. The **glDrawPixels** function multiplies the resulting floating-point depth value by GL_DEPTH_SCALE and adds it to GL_DEPTH_BIAS. The result is clamped to the range [0,1].
3. The **glDrawPixels** function converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, and then assigning *x* and *y* window coordinates to the *n* th fragment such that *x*? = xr + *n* mod *width*\
   *y*? = *y*r + *n/width*\
    where (xr ,*y*r ) is the current raster position.\
4. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. The **glDrawPixels** function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.

|
| **GL_RGBA** | Each pixel is a four-component group in this order: red, green, blue, alpha. <br>
1. The **glDrawPixels** function converts floating-point values directly to an internal floating-point format with unspecified precision. Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.
2. The **glDrawPixels** function multiplies the resulting floating-point color values by GL_c_SCALE and adds them to GL_c_BIAS, where *c* is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1].
3. If GL_MAP_COLOR is true, **glDrawPixels** scales each color component by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaces the component by the value that it references in that table; *c* is R, G, B, or A, respectively.
4. The **glDrawPixels** function converts the resulting RGBA colors to fragments by attaching the current raster position *z*-coordinate and texture coordinates to each pixel, then assigning *x* and *y* window coordinates to the *n*th fragment such that *x*? = *x*r + *n* mod *width*\
   *y*? = *y*r + *n /width*\
    where (*x*r ,*y*r ) is the current raster position.\
5. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. The **glDrawPixels** function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.

|
| **GL_RED** | Each pixel is a single red component.<br> The **glDrawPixels** function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_GREEN** | Each pixel is a single green component.<br> The **glDrawPixels** function converts this component to the internal floating-point format in the same way that the green component of an RGBA pixel is, and then converts it to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_BLUE** | Each pixel is a single blue component.<br> The **glDrawPixels** function converts this component to the internal floating-point format in the same way that the blue component of an RGBA pixel is, and then converts it to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_ALPHA** | Each pixel is a single alpha component.<br> The **glDrawPixels** function converts this component to the internal floating-point format in the same way that the alpha component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to 0.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_RGB** | Each pixel is a group of three components in this order: red, green, blue. The **glDrawPixels** function converts each component to the internal floating-point format in the same way that the red, green, and blue components of an RGBA pixel are. The color triple is converted to an RGBA pixel with alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_LUMINANCE** | Each pixel is a single luminance component.<br> The **glDrawPixels** function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_LUMINANCE_ALPHA** | Each pixel is a group of two components in this order: luminance, alpha.<br> The **glDrawPixels** function converts the two components to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts them to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br> |
| **GL_BGR_EXT** | Each pixel is a group of three components in this order: blue, green, red.<br> GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br> |
| **GL_BGRA_EXT** | Each pixel is a group of four components in this order: blue, green, red, alpha.<br> GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br> |

*type*

The data type for *pixels*. The following are the accepted symbolic constants and their meanings.

| Value | Meaning |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| **GL\_UNSIGNED\_BYTE** | Unsigned 8-bit integer<br> |
| **GL\_BYTE** | Signed 8-bit integer<br> |
| **GL\_BITMAP** | Single bits in unsigned 8-bit integers<br> |
| **GL\_UNSIGNED\_SHORT** | Unsigned 16-bit integer<br> |
| **GL\_SHORT** | Signed 16-bit integer<br> |
| **GL\_UNSIGNED\_INT** | Unsigned 32-bit integer<br> |
| **GL\_INT** | 32-bit integer<br> |
| **GL\_FLOAT** | Single-precision floating-point<br> |

*pixels*

A pointer to the pixel data.

## Return value

This function does not return a value.

## Error codes

The following error codes can be retrieved by the [**glGetError**](https://learn.microsoft.com/windows/win32/opengl/glgeterror) function.

| Name | Meaning |
|-------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GL\_INVALID\_VALUE** | Either *width* or *height* was negative.<br> |
| **GL\_INVALID\_ENUM** | Either *format* or *type* was not an accepted value. <br> |
| **GL\_INVALID\_OPERATION** | *format* was GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA, and OpenGL was in color-index mode.<br> |
| **GL\_INVALID\_ENUM** | *type* was GL\_BITMAP and *format* was not either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX.<br> |
| **GL\_INVALID\_OPERATION** | *format* was GL\_STENCIL\_INDEX and there was no stencil buffer.<br> |
| **GL\_INVALID\_OPERATION** | The function was called between a call to [**glBegin**](https://learn.microsoft.com/windows/win32/opengl/glbegin) and the corresponding call to [**glEnd**](https://learn.microsoft.com/windows/win32/opengl/glend).<br> |

## Remarks

The **glDrawPixels** function reads pixel data from memory and writes it into the framebuffer relative to the current raster position. Use [**glRasterPos**](https://learn.microsoft.com/windows/win32/opengl/glrasterpos-functions) to set the current raster position, and use [**glGet**](https://learn.microsoft.com/windows/win32/opengl/glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv) with argument GL\_CURRENT\_RASTER\_POSITION to query the raster position.

Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the framebuffer. These parameters are set with four functions: [**glPixelStore**](https://learn.microsoft.com/windows/win32/opengl/glpixelstore-functions), [**glPixelTransfer**](https://learn.microsoft.com/windows/win32/opengl/glpixeltransfer), [**glPixelMap**](https://learn.microsoft.com/windows/win32/opengl/glpixelmap), and [**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom). This topic describes the effects on **glDrawPixels** of many, but not all, of the parameters specified by these four functions.

Data is read from *pixels* as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on *type*. Each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on *format*. Indexes are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on *format*. Both individual indexes and groups of components are referred to as pixels. If *type* is GL\_BITMAP, the data must be unsigned bytes, and *format* must be either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX. Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](https://learn.microsoft.com/windows/win32/opengl/glpixelstore-functions)).

The *width* by *height* pixels are read from memory, starting at location *pixels*. By default, these pixels are taken from adjacent memory locations, except that after all *width* pixels are read, the read pointer is advanced to the next 4-byte boundary. The **glPixelStore** function specifies the 4-byte row alignment with argument GL\_UNPACK\_ALIGNMENT, and you can set it to 1, 2, 4, or 8 bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read, and after all *width* pixels are read. The **glPixelStore** function operates on each of the *width-by-height* pixels that it reads from memory in the same way, based on the values of several parameters specified by [**glPixelTransfer**](https://learn.microsoft.com/windows/win32/opengl/glpixeltransfer) and [**glPixelMap**](https://learn.microsoft.com/windows/win32/opengl/glpixelmap). The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by *format*.

The rasterization described thus far assumes pixel zoom factors of 1.0. If you use [**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows. If (*xr,yr*) is the current raster position, and a given pixel is in the *n*th column and *m*th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at

(*x*r + *zoom*? *n*, *y*r + *zoom*y *m*)

(*x*r + *zoom*? (*n* + 1), *y*r + *zoom*y (*m* + 1))

where *zoom*? is the value of GL\_ZOOM\_X and *zoom*y is the value of GL\_ZOOM\_Y.

The following functions retrieve information related to **glDrawPixels**:

[**glGet**](https://learn.microsoft.com/windows/win32/opengl/glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv) with argument GL\_CURRENT\_RASTER\_POSITION

**glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID

## Requirements

| Requirement | Value |
|-------------------------------------|-----------------------------------------------------------------------------------------|
| Minimum supported client<br> | Windows 2000 Professional \[desktop apps only\]<br> |
| Minimum supported server<br> | Windows 2000 Server \[desktop apps only\]<br> |
| Header<br> | Gl.h |
| Library<br> | Opengl32.lib |
| DLL<br> | Opengl32.dll |

## See also

[**glAlphaFunc**](https://learn.microsoft.com/windows/win32/opengl/glalphafunc)

[**glBegin**](https://learn.microsoft.com/windows/win32/opengl/glbegin)

[**glBlendFunc**](https://learn.microsoft.com/windows/win32/opengl/glblendfunc)

[**glCopyPixels**](https://learn.microsoft.com/windows/win32/opengl/glcopypixels)

[**glDepthFunc**](https://learn.microsoft.com/windows/win32/opengl/gldepthfunc)

[**glEnd**](https://learn.microsoft.com/windows/win32/opengl/glend)

[**glGet**](https://learn.microsoft.com/windows/win32/opengl/glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv)

[**glLogicOp**](https://learn.microsoft.com/windows/win32/opengl/gllogicop)

[**glPixelMap**](https://learn.microsoft.com/windows/win32/opengl/glpixelmap)

[**glPixelStore**](https://learn.microsoft.com/windows/win32/opengl/glpixelstore-functions)

[**glPixelTransfer**](https://learn.microsoft.com/windows/win32/opengl/glpixeltransfer)

[**glPixelZoom**](https://learn.microsoft.com/windows/win32/opengl/glpixelzoom)

[**glRasterPos**](https://learn.microsoft.com/windows/win32/opengl/glrasterpos-functions)

[**glReadPixels**](https://learn.microsoft.com/windows/win32/opengl/glreadpixels)

[**glScissor**](https://learn.microsoft.com/windows/win32/opengl/glscissor)

[**glStencilFunc**](https://learn.microsoft.com/windows/win32/opengl/glstencilfunc)

