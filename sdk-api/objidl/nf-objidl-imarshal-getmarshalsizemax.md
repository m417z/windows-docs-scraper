# IMarshal::GetMarshalSizeMax

## Description

Retrieves the maximum size of the buffer that will be needed during marshaling.

## Parameters

### `riid` [in]

A reference to the identifier of the interface to be marshaled.

### `pv` [in]

The interface pointer to be marshaled. This parameter can be **NULL**.

### `dwDestContext` [in]

The destination context where the specified interface is to be unmarshaled. Possible values come from the enumeration [MSHCTX](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshctx). Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).

### `pvDestContext` [in]

This parameter is reserved and must be **NULL**.

### `mshlflags` [in]

Indicates whether the data to be marshaled is to be transmitted back to the client process (the typical case) or written to a global table, where it can be retrieved by multiple clients. Possible values come from the [MSHLFLAGS](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshlflags) enumeration.

### `pSize` [out]

A pointer to a variable that receives the maximum size of the buffer.

## Return value

This method can return the standard return values E_FAIL and S_OK, as well as the following value.

| Return code | Description |
| --- | --- |
| **E_NOINTERFACE** | The specified interface is not supported. |

## Remarks

This method is called indirectly, in a call to [CoGetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmarshalsizemax), by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the [IClassFactory](https://learn.microsoft.com/windows/desktop/api/unknwnbase/nn-unknwnbase-iclassfactory) and [IOleItemContainer](https://learn.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleitemcontainer) interfaces. For purposes of discussion, the code responsible for marshaling a pointer is called the *marshaling stub*.

To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be written to the marshaling stream and the proxy's CLSID.

The marshaling stub obtains these two pieces of information with successive calls to [CoGetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmarshalsizemax) and [CoMarshalInterface](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface).

### Notes to Callers

The marshaling stub, through a call to [CoGetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmarshalsizemax), calls the object's implementation of this method to preallocate the stream buffer that will be passed to [MarshalInterface](https://learn.microsoft.com/windows/desktop/api/objidl/nf-objidl-imarshal-marshalinterface).

You do not explicitly call this method if you are implementing existing COM interfaces or using the Microsoft Interface Definition Language (MIDL) to define your own custom interfaces. In either case, the MIDL-generated stub automatically makes the call.

If you are not using MIDL to define your own interface (see [Defining COM Interfaces](https://learn.microsoft.com/windows/desktop/com/defining-com-interfaces)), your marshaling stub does not have to call **GetMarshalSizeMax**, although doing so is highly recommended. An object knows better than an interface stub what the maximum size of a marshaling data packet is likely to be. Therefore, unless you are providing an automatically growing stream that is so efficient that the overhead of expanding it is insignificant, you should call this method even when implementing your own interfaces.

The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.

### Notes to Implementers

Your implementation of [MarshalInterface](https://learn.microsoft.com/windows/desktop/api/objidl/nf-objidl-imarshal-marshalinterface) will use the preallocated buffer to write marshaling data into the stream. If the buffer is too small, the marshaling operation will fail. Therefore, the value returned by this method must be a conservative estimate of the amount of data that will be needed to marshal the interface. Violation of this requirement should be treated as a catastrophic error.

In a subsequent call to [MarshalInterface](https://learn.microsoft.com/windows/desktop/api/objidl/nf-objidl-imarshal-marshalinterface), your [IMarshal](https://learn.microsoft.com/windows/desktop/api/objidl/nn-objidl-imarshal) implementation cannot rely on the caller actually having called **GetMarshalSizeMax** beforehand. It must still be wary of STG_E_MEDIUMFULL errors returned by the stream and be prepared to handle them gracefully.

To ensure that your implementation of **GetMarshalSizeMax** will continue to work properly as new destination contexts are supported in the future, delegate marshaling to the COM default implementation for all *dwDestContext* values that your implementation does not understand. To delegate marshaling to the COM default implementation, call the [CoGetStandardMarshal](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetstandardmarshal) function.

## See also

[CoGetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmarshalsizemax)

[IMarshal](https://learn.microsoft.com/windows/desktop/api/objidl/nn-objidl-imarshal)