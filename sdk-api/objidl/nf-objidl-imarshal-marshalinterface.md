# IMarshal::MarshalInterface

## Description

Marshals an interface pointer.

## Parameters

### `pStm` [in]

A pointer to the stream to be used during marshaling.

### `riid` [in]

A reference to the identifier of the interface to be marshaled. This interface must be derived from the [IUnknown](https://learn.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown) interface.

### `pv` [in]

A pointer to the interface pointer to be marshaled. This parameter can be **NULL** if the caller does not have a pointer to the desired interface.

### `dwDestContext` [in]

The destination context where the specified interface is to be unmarshaled. Possible values for *dwDestContext* come from the enumeration [MSHCTX](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshctx). Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current process (MSHCTX_LOCAL).

### `pvDestContext` [in]

This parameter is reserved and must be 0.

### `mshlflags` [in]

Indicates whether the data to be marshaled is to be transmitted back to the client process—the typical case—or written to a global table, where it can be retrieved by multiple clients. Possible values come from the [MSHLFLAGS](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshlflags) enumeration.

## Return value

This method can return the standard return value E_FAIL, as well as the following values.

| Return code | Description |
| --- | --- |
| **S_OK** | The interface pointer was marshaled successfully. |
| **E_NOINTERFACE** | The specified interface is not supported. |
| **STG_E_MEDIUMFULL** | The stream is full. |

## Remarks

This method is called indirectly, in a call to [CoMarshalInterface](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface), by whatever code in the server process is responsible for marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the [IClassFactory](https://learn.microsoft.com/windows/desktop/api/unknwnbase/nn-unknwnbase-iclassfactory) and [IOleItemContainer](https://learn.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleitemcontainer) interfaces. For purposes of discussion, the code responsible for marshaling a pointer is called the *marshaling stub*.

### Notes to Callers

Typically, rather than calling **MarshalInterface** directly, your marshaling stub instead should call the [CoMarshalInterface](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) function, which contains a call to this method. The stub makes this call to command an object to write its marshaling data into a stream. The stub then either passes the marshaling data back to the client process or writes it to a global table, where it can be unmarshaled by multiple clients. The stub's call to **CoMarshalInterface** is normally preceded by a call to [CoGetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmarshalsizemax) to get the maximum size of the stream buffer into which the marshaling data will be written.

You do not explicitly call this method if you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language (MIDL). In either case, the MIDL-generated stub automatically makes the call.

If you are not using MIDL to define your own interface, your marshaling stub must call this method, either directly or indirectly. Your stub implementation should call **MarshalInterface** immediately after its previous call to [IMarshal::GetMarshalSizeMax](https://learn.microsoft.com/windows/desktop/api/objidl/nf-objidl-imarshal-getmarshalsizemax) returns. Because the value returned by **GetMarshalSizeMax** is guaranteed to be valid only as long as the internal state of the object being marshaled does not change, a delay in calling **MarshalInterface** runs the risk that the object will require a larger stream buffer than originally indicated.

If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the *pv* parameter to pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the proxy does not have to call [QueryInterface](https://learn.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) on itself. If a caller does not have a pointer to the interface to be marshaled, it can pass **NULL**.

### Notes to Implementers

Your implementation of **MarshalInterface** must write to the stream whatever data is needed to initialize the proxy on the receiving side. Such data would include a reference to the interface to be marshaled, a [MSHLFLAGS](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshlflags) value specifying whether the data should be returned to the client process or written to a global table, and whatever is needed to connect to the object, such as a named pipe, handle to a window, or pointer to an RPC channel.

Your implementation should not assume that the stream is large enough to hold all the data. Rather, it should gracefully handle a STG_E_MEDIUMFULL error. Just before exiting, your implementation should position the seek pointer in the stream immediately after the last byte of data written.

If the pv parameter is **NULL** and your implementation needs an interface pointer, it can call [QueryInterface](https://learn.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) on the current object to get it. The *pv* parameter exists merely to improve efficiency.

To ensure that your implementation of **MarshalInterface** continues to work properly as new destination contexts are supported in the future, delegate marshaling to the COM default implementation for all *dwDestContext* values that your implementation does not handle. To delegate marshaling to the COM default implementation, call the [CoGetStandardMarshal](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetstandardmarshal) helper function.

Using the [MSHLFLAGS](https://learn.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-mshlflags) enumeration, callers can specify whether an interface pointer is to be marshaled back to a single client or written to a global table, where it can be unmarshaled by multiple clients. You must make sure that your object can handle calls from the multiple proxies that might be created from the same initialization data.

## See also

[CoMarshalInterface](https://learn.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface)

[IMarshal](https://learn.microsoft.com/windows/desktop/api/objidl/nn-objidl-imarshal)