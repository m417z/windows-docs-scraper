# CryptVerifySignatureA function

## Description

**Important** This API is deprecated. New and existing software should start using [Cryptography Next Generation APIs.](https://learn.microsoft.com/windows/desktop/SecCNG/cng-portal) Microsoft may remove this API in future releases.

The **CryptVerifySignature** function verifies the signature of a [hash object](https://learn.microsoft.com/windows/desktop/SecGloss/h-gly).

Before calling this function,
[CryptCreateHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash) must be called to create the handle of a hash object.
[CryptHashData](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata) or
[CryptHashSessionKey](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey) is then used to add data or [session keys](https://learn.microsoft.com/windows/desktop/SecGloss/s-gly) to the hash object.

After **CryptVerifySignature** completes, only
[CryptDestroyHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash) can be called by using the *hHash* handle.

## Parameters

### `hHash` [in]

A handle to the hash object to verify.

### `pbSignature` [in]

The address of the signature data to be verified.

### `dwSigLen` [in]

The number of bytes in the *pbSignature* signature data.

### `hPubKey` [in]

A handle to the [public key](https://learn.microsoft.com/windows/desktop/SecGloss/p-gly) to use to authenticate the signature. This public key must belong to the [key pair](https://learn.microsoft.com/windows/desktop/SecGloss/k-gly) that was originally used to create the [digital signature](https://learn.microsoft.com/windows/desktop/SecGloss/d-gly).

### `szDescription` [in]

This parameter should no longer be used and must be set to **NULL** to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.

### `dwFlags` [in]

The following flag values are defined.

| Value | Meaning |
| --- | --- |
| **CRYPT_NOHASHOID**<br><br>0x00000001 | This flag is used with RSA providers. When verifying the signature, the hash [object identifier](https://learn.microsoft.com/windows/desktop/SecGloss/o-gly) (OID) is not expected to be present or checked. If this flag is not set, the hash OID in the default signature is verified as specified in the definition of DigestInfo in PKCS #7. <br><br> |
| **CRYPT_TYPE2_FORMAT**<br><br>0x00000002 | This flag is not used. |
| **CRYPT_X931_FORMAT**<br><br>0x00000004 | Use X.931 support for the FIPS 186-2â€“compliant version of RSA (rDSA). |

## Return value

If the function succeeds, the return value is **TRUE**.

If the function fails, the return value is **FALSE**. For extended error information, call
[GetLastError](https://learn.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).

The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.

| Return code | Description |
| --- | --- |
| **ERROR_INVALID_HANDLE** | One of the parameters specifies a handle that is not valid. |
| **ERROR_INVALID_PARAMETER** | One of the parameters contains a value that is not valid. This is most often a pointer that is not valid. |
| **NTE_BAD_FLAGS** | The *dwFlags* parameter is nonzero. |
| **NTE_BAD_HASH** | The hash object specified by the *hHash* parameter is not valid. |
| **NTE_BAD_KEY** | The *hPubKey* parameter does not contain a handle to a valid [public key](https://learn.microsoft.com/windows/desktop/SecGloss/p-gly). |
| **NTE_BAD_SIGNATURE** | The signature was not valid. This might be because the data itself has changed, the description string did not match, or the wrong public key was specified by *hPubKey*.<br><br>This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature. |
| **NTE_BAD_UID** | The [cryptographic service provider](https://learn.microsoft.com/windows/desktop/SecGloss/c-gly) (CSP) context that was specified when the hash object was created cannot be found. |
| **NTE_NO_MEMORY** | The CSP ran out of memory during the operation. |

## Remarks

The **CryptVerifySignature** function completes the hash. After this call, no more data can be added to the hash. Additional calls to
[CryptHashData](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata) or
[CryptHashSessionKey](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey) fail. After the application is done with the hash,
[CryptDestroyHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash) should be called to destroy the hash object.

If you generate a signature by using the .NET Framework APIs and try to verify it by using the **CryptVerifySignature** function, the function will fail and [GetLastError](https://learn.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) will return **NTE_BAD_SIGNATURE**. This is due to the different byte orders between the native Win32 API and the .NET Framework API.

The native cryptography API uses little-endian byte order while the .NET Framework API uses big-endian byte order. If you are verifying a signature generated by using a .NET Framework API, you must swap the order of signature bytes before calling the **CryptVerifySignature** function to verify the signature.

#### Examples

For an example that uses the **CryptVerifySignature** function, see [Example C Program: Signing a Hash and Verifying the Hash Signature](https://learn.microsoft.com/windows/desktop/SecCrypto/example-c-program-signing-a-hash-and-verifying-the-hash-signature).

> [!NOTE]
> The wincrypt.h header defines CryptVerifySignature as an alias that automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](https://learn.microsoft.com/windows/win32/intl/conventions-for-function-prototypes).

## See also

[CryptCreateHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash)

[CryptDestroyHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash)

[CryptHashData](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata)

[CryptHashSessionKey](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey)

[CryptSignHash](https://learn.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha)

[Hash and Digital Signature Functions](https://learn.microsoft.com/windows/desktop/SecCrypto/cryptography-functions)